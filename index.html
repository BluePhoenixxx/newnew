<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Christmas Interactive Experience</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", sans-serif;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
      }
      #ui-layer {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 100;
      }
      .badge {
        display: inline-block;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #ffd700;
        color: #ffd700;
        padding: 10px 25px;
        border-radius: 50px;
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
        text-transform: uppercase;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        text-shadow: 0 0 10px #ffd700;
      }
      .guide {
        color: #ccc;
        font-size: 13px;
        margin-bottom: 20px;
        text-shadow: 0 2px 4px black;
      }
      button {
        pointer-events: auto;
        cursor: pointer;
        background: linear-gradient(to bottom, #d32f2f, #8b0000);
        color: #fff;
        border: 2px solid #ffd700;
        padding: 15px 50px;
        border-radius: 30px;
        font-weight: 800;
        font-size: 16px;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }
      #camera-preview {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 120px;
        height: 90px;
        border: 2px solid rgba(255, 0, 0, 0.5);
        transform: scaleX(-1);
        opacity: 0.6;
        border-radius: 8px;
      }
    </style>
  </head>

  <body>
    <div id="ui-layer">
      <div id="status" class="badge">üéÑ GI√ÅNG SINH AN L√ÄNH üéÑ</div>
      <div class="guide">
        üñê <b>X√≤e:</b> Bung Qu√† & ·∫¢nh &nbsp;|&nbsp; üëå <b>Pinch:</b> Xem chi
        ti·∫øt &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> Thu c√¢y th√¥ng
      </div>
      <button id="btnStart" onclick="startSystem()">B·∫ÆT ƒê·∫¶U TR·∫¢I NGHI·ªÜM</button>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      // ==========================================
      // 1. C·∫§U H√åNH NH·∫†C V√Ä T√ÄI NGUY√äN
      // ==========================================
      const MUSIC_URL = "./img/1.mp3";
      const bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 0.8;

      const loader = new THREE.TextureLoader();
      const photoFiles = [
        "./img/1.png",
        "./img/image.png",
        "./img/2.png",
        "./img/3.png",
        "./img/4.png",
      ];
      const photoTextures = photoFiles.map((f) => loader.load(f));

      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        const cx = 64,
          cy = 64;

        if (type === "gold_glow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.5, "#FFD700");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "red_light") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0, "#FFAAAA");
          grd.addColorStop(0.3, "#FF0000");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "gift_red") {
          ctx.fillStyle = "#D32F2F";
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
        }
        return new THREE.CanvasTexture(canvas);
      }

      const textures = {
        gold: createCustomTexture("gold_glow"),
        red: createCustomTexture("red_light"),
        gift: createCustomTexture("gift_red"),
      };

      // ==========================================
      // 2. KH·ªûI T·∫†O 3D & H·ªÜ TH·ªêNG H·∫†T
      // ==========================================
      const CONFIG = {
        goldCount: 2000,
        redCount: 300,
        giftCount: 150,
        explodeRadius: 65,
        photoOrbitRadius: 25,
        treeHeight: 70,
        treeBaseRadius: 35,
      };
      let scene,
        camera,
        renderer,
        groupGold,
        groupRed,
        groupGift,
        titleMesh,
        starMesh;
      let photoMeshes = [],
        state = "TREE",
        selectedIndex = 0,
        handX = 0.5;

      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        groupGold = createParticleSystem("gold", CONFIG.goldCount, 2.0);
        groupRed = createParticleSystem("red", CONFIG.redCount, 3.5);
        groupGift = createParticleSystem("gift", CONFIG.giftCount, 3.0);

        createPhotos();
        createDecorations();
        animate();
      }

      function createParticleSystem(type, count, size) {
        const pPositions = [],
          pExplodeTargets = [],
          pTreeTargets = [];
        for (let i = 0; i < count; i++) {
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          let radiusRatio =
            type === "gold"
              ? Math.sqrt(Math.random())
              : 0.9 + Math.random() * 0.1;
          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
          const r = maxR * radiusRatio;
          const theta = Math.random() * Math.PI * 2;
          pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          const u = Math.random(),
            v = Math.random();
          const phi = Math.acos(2 * v - 1),
            lam = 2 * Math.PI * u;
          let radMult = type === "gift" ? 1.2 : 1.0;
          const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
          pExplodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );
          pPositions.push(
            pTreeTargets[i * 3],
            pTreeTargets[i * 3 + 1],
            pTreeTargets[i * 3 + 2]
          );
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(pPositions, 3)
        );
        geo.userData = { tree: pTreeTargets, explode: pExplodeTargets };
        const mat = new THREE.PointsMaterial({
          size,
          map: textures[type],
          transparent: true,
          blending:
            type === "gift" ? THREE.NormalBlending : THREE.AdditiveBlending,
          depthWrite: false,
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        for (let i = 0; i < 5; i++) {
          const mesh = new THREE.Mesh(
            geo,
            new THREE.MeshBasicMaterial({
              map: photoTextures[i],
              side: THREE.DoubleSide,
            })
          );
          const border = new THREE.Mesh(
            new THREE.PlaneGeometry(9, 9),
            borderMat
          );
          border.position.z = -0.1;
          mesh.add(border);
          mesh.visible = false;
          mesh.scale.set(0, 0, 0);
          scene.add(mesh);
          photoMeshes.push(mesh);
        }
      }

      function createDecorations() {
        const canvas = document.createElement("canvas");
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.font = 'bold italic 90px "Times New Roman"';
        ctx.fillStyle = "#FFD700";
        ctx.textAlign = "center";
        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 40;
        ctx.fillText("MERRY CHRISTMAS", 512, 130);
        titleMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(60, 15),
          new THREE.MeshBasicMaterial({
            map: new THREE.CanvasTexture(canvas),
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        titleMesh.position.y = 50;
        scene.add(titleMesh);

        starMesh = new THREE.Mesh(
          new THREE.PlaneGeometry(12, 12),
          new THREE.MeshBasicMaterial({
            map: textures.gold,
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        starMesh.position.y = CONFIG.treeHeight / 2 + 2;
        scene.add(starMesh);
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const speed = 0.06;
        const handRotY = (handX - 0.5) * 2.5;

        [groupGold, groupRed, groupGift].forEach((g) => {
          const pos = g.geometry.attributes.position.array;
          const targets =
            state === "TREE"
              ? g.geometry.userData.tree
              : g.geometry.userData.explode;
          for (let i = 0; i < pos.length; i++)
            pos[i] += (targets[i] - pos[i]) * speed;
          g.geometry.attributes.position.needsUpdate = true;
          if (state === "TREE") g.rotation.y += 0.003;
          else g.rotation.y += (handRotY - g.rotation.y) * 0.05;
        });

        if (state === "TREE") {
          titleMesh.visible = starMesh.visible = true;
          photoMeshes.forEach((m) => {
            m.visible = false;
            m.scale.set(0, 0, 0);
          });
        } else if (state === "EXPLODE") {
          titleMesh.visible = starMesh.visible = false;
          photoMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = groupGold.rotation.y + i * ((Math.PI * 2) / 5);
            mesh.position.lerp(
              new THREE.Vector3(
                Math.sin(angle) * 25,
                Math.sin(time + i) * 3,
                Math.cos(angle) * 25
              ),
              0.1
            );
            mesh.lookAt(camera.position);
            const s = mesh.position.z > 5 ? 1.8 : 0.6;
            mesh.scale.lerp(new THREE.Vector3(s, s, s), 0.1);
          });
        } else if (state === "PHOTO") {
          photoMeshes.forEach((mesh, i) => {
            if (i === selectedIndex) {
              mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
              mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
            } else mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
          });
        }
        renderer.render(scene, camera);
      }

      // ==========================================
      // 3. X·ª¨ L√ù NH·∫†C & CAMERA BI·∫æN ƒê·ªîI
      // ==========================================
      function startSystem() {
        // Ph√°t nh·∫°c ngay khi nh·∫•n n√∫t
        bgMusic
          .play()
          .then(() => {
            console.log("Nh·∫°c ƒëang ph√°t...");
          })
          .catch((e) => console.error("L·ªói ph√°t nh·∫°c:", e));

        document.getElementById("btnStart").style.display = "none";
        init3D();

        const video = document.getElementsByClassName("input_video")[0];
        const canvas = document.getElementById("camera-preview");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");

        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 0,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        hands.onResults((results) => {
          ctx.clearRect(0, 0, 120, 90);
          ctx.drawImage(results.image, 0, 0, 120, 90);
          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            handX = lm[9].x;
            const wrist = lm[0];
            const avgDist =
              [8, 12, 16, 20].reduce(
                (acc, i) =>
                  acc + Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y),
                0
              ) / 4;
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

            if (avgDist < 0.25) {
              state = "TREE";
              statusDiv.innerText = "‚úä C√ÇY TH√îNG";
            } else if (pinchDist < 0.05) {
              state = "PHOTO";
              statusDiv.innerText = "üëå XEM ·∫¢NH";
            } else {
              state = "EXPLODE";
              statusDiv.innerText = "üñê BUNG QU√Ä";
            }
          }
        });

        const cam = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 320,
          height: 240,
        });
        cam.start();
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
